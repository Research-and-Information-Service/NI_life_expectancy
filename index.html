<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>NI DEA Life Expectancy Map</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Chart.js -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.3.0/dist/chart.umd.min.js"></script>

<style>
  body { margin:0; font-family: Arial, sans-serif; }
  #map { height: 100vh; }

  .controls {
    position: absolute; top: 10px; left: 10px; z-index: 1000;
    background: white; padding: 10px; border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    width: 300px;
  }
  .tabs button {
    margin: 2px; padding: 6px 10px; border: none; cursor: pointer;
    background: #eee; border-radius: 4px;
  }
  .tabs button.active { background: #0078A8; color: white; }
  .slider-container { margin-top: 10px; }
  #year-slider { width: 100%; }
  #play-btn { margin-top: 6px; padding: 6px 10px; background: #eee; border-radius: 4px; cursor: pointer; }

  .legend { background: white; padding: 6px; border-radius: 4px; font-size: 12px; }
  .legend i { width: 18px; height: 18px; float: left; margin-right: 8px; opacity: 0.95; }

  /* Sidebar */
  #sidebar {
    position: absolute;
    right: 10px;
    top: 10px;
    width: 360px;
    max-height: calc(100vh - 20px);
    overflow: auto;
    z-index: 1000;
    background: white;
    padding: 12px;
    border-radius: 6px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    display: none;
  }
  #sidebar h3 { margin: 0 0 8px 0; }
  #chart-container { height: 220px; }
  .btn { padding: 6px 10px; border-radius: 4px; background:#0078A8; color:white; cursor:pointer; border:none; }
  .small { font-size: 12px; padding:4px 8px; }
  .mode-toggle { margin-top:8px; }

  /* Loading spinner */
  #spinner {
    position: absolute;
    left: 50%; top: 50%;
    transform: translate(-50%,-50%);
    z-index: 2000;
    display: none;
  }
  .spinner-dot {
    width: 16px; height: 16px; margin: 4px;
    border-radius: 50%; display: inline-block;
    background: #0078A8; opacity: 0.9;
    animation: spin 0.9s linear infinite;
  }
  @keyframes spin { 0% { transform: scale(1); } 50% { transform: scale(0.45); } 100% { transform: scale(1); } }

  /* Ensure SVG path transitions (color) */
  .leaflet-interactive {
    transition: fill 600ms ease, fill-opacity 600ms ease, stroke 300ms ease;
  }
</style>
</head>
<body>
<div id="map"></div>

<div id="spinner">
  <div class="spinner-dot" style="animation-delay:0s"></div>
  <div class="spinner-dot" style="animation-delay:0.15s"></div>
  <div class="spinner-dot" style="animation-delay:0.3s"></div>
</div>

<div class="controls">
  <div class="tabs">
    <button id="tab-males" class="active">Males</button>
    <button id="tab-females">Females</button>
  </div>

  <div class="slider-container">
    <input type="range" id="year-slider" min="0" max="0" step="1" value="0" />
    <div id="year-label" style="margin-top:5px;font-weight:bold;"></div>
    <button id="play-btn">▶ Play Years</button>
  </div>

  <div class="mode-toggle" style="margin-top:10px;">
    <label><input type="radio" name="mode" value="absolute" checked> Show absolute (year)</label><br>
    <label><input type="radio" name="mode" value="change"> Show change (first → last)</label>
  </div>
</div>



<div id="sidebar">
  <button id="close-sidebar" class="small" style="float:right">Close</button>
  <h3 id="sidebar-title">DEA details</h3>
  <div id="sidebar-meta"></div>
  <div id="chart-container">
    <canvas id="deaChart"></canvas>
  </div>
  <!-- Removed buttons, kept structure clean -->
</div>


</div>

<script>
// Use the uploaded file path (environment will map this for you).
const geojsonUrl = 'DEA_data.geojson';

// Colour ramps
const colors = ['#f7fcf0','#ccebc5','#a8ddb5','#7bccc4','#4eb3d3','#2b8cbe','#08589e'];
const changeColors = ['#d73027','#fc8d59','#fee08b','#ffffbf','#d9ef8b','#91cf60','#1a9850'];

let breaks = [];
let selectedSex = 'Males';
let years = [];
let currentYearIndex = 0;
let playInterval = null;
let mode = 'absolute';

const map = L.map('map').setView([54.7, -6.6], 8);
L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
  attribution: '&copy; OpenStreetMap & Carto'
}).addTo(map);


const legend = L.control({position: 'bottomright'});
legend.onAdd = function() {
  const div = L.DomUtil.create('div', 'legend');
  div.innerHTML = '<div id="legend-content"></div>';
  return div;
};
legend.addTo(map);

const spinner = document.getElementById('spinner');
function showSpinner(on=true){ spinner.style.display = on ? 'block' : 'none'; }

let deaLayer = null;
let deaDataCache = null;
let lastHoveredLayer = null;
let deaChart = null;

// Show spinner while loading
showSpinner(true);

fetch(geojsonUrl)
  .then(r => {
    if (!r.ok) throw new Error('Could not load GeoJSON: ' + r.statusText);
    return r.json();
  })
  .then(data => {
    deaDataCache = data;

    // Extract years
    const yearSet = new Set();
    data.features.forEach(f => {
      if (Array.isArray(f.properties.data)) f.properties.data.forEach(d => yearSet.add(d.GroupedYear));
    });
    years = Array.from(yearSet).sort();
    if (years.length === 0) {
      showSpinner(false);
      alert('No year data found in GeoJSON properties.data[].GroupedYear');
      return;
    }
    document.getElementById('year-slider').max = years.length - 1;
    updateYearLabel();

    computeBreaks(data);

    const highlightStyle = { weight: 3, color: '#000', fillOpacity: 1 };

    deaLayer = L.geoJSON(data, {
      style: feature => ({
        weight: 1,
        color: '#555',
        fillColor: getFeatureColor(feature),
        fillOpacity: 0.85
      }),
      onEachFeature: (feature, layer) => {
        // ensure path has transition class (leaflet adds class automatically, but defend)
        layer.on('add', () => {
          if (layer._path) layer._path.classList.add('leaflet-interactive');
        });

        // Hover drives the sidebar (Option C)
        layer.on('mouseover', function(e) {
          if (lastHoveredLayer && lastHoveredLayer !== this) {
            deaLayer.resetStyle(lastHoveredLayer);
          }
          lastHoveredLayer = this;
          this.setStyle(highlightStyle);
          // show sidebar populated
          populateSidebarFromFeature(this.feature);
          document.getElementById('sidebar').style.display = 'block';
        });

        layer.on('mouseout', function() {
          // reset style (but keep sidebar open only if mouseover moves to another feature immediately;
          // spec asked hover drives sidebar — hide sidebar on mouseout)
          deaLayer.resetStyle(this);
          lastHoveredLayer = null;
          document.getElementById('sidebar').style.display = 'none';
          if (deaChart) { deaChart.destroy(); deaChart = null; }
        });

        // click zooms-to
        layer.on('click', function() {
          if (layer.getBounds) map.fitBounds(layer.getBounds().pad(0.4));
        });
      }
    }).addTo(map);

    // Fit to bounds
    map.fitBounds(deaLayer.getBounds(), {padding: [20,20]});

    updateLegend();

    showSpinner(false);
  })
  .catch(err => {
    console.error(err);
    showSpinner(false);
    alert('Error loading GeoJSON: ' + err.message);
  });

// ---------- Helpers ----------

function computeBreaks(data) {
  const vals = [];
  data.features.forEach(f => {
    const rec = (f.properties.data||[]).find(d => d.Sex === selectedSex && d.GroupedYear === years[currentYearIndex]);
    if (rec && typeof rec.Value === 'number') vals.push(rec.Value);
  });
  vals.sort((a,b)=>a-b);
  if (vals.length === 0) { breaks = [0,0,0,0]; return; }
  breaks = [
    round1(vals[Math.floor(vals.length*0.2)]),
    round1(vals[Math.floor(vals.length*0.4)]),
    round1(vals[Math.floor(vals.length*0.6)]),
    round1(vals[Math.floor(vals.length*0.8)])
  ];
}

function computeChangeBreaks(data) {
  const diffs = [];
  const fYr = years[0], lYr = years[years.length-1];
  data.features.forEach(f => {
    const a = (f.properties.data||[]).find(d => d.Sex===selectedSex && d.GroupedYear===fYr);
    const b = (f.properties.data||[]).find(d => d.Sex===selectedSex && d.GroupedYear===lYr);
    if (a && b && typeof a.Value === 'number' && typeof b.Value === 'number') diffs.push(round1(b.Value - a.Value));
  });
  diffs.sort((a,b)=>a-b);
  if (diffs.length === 0) return [0,0,0,0];
  return [
    diffs[Math.floor(diffs.length*0.2)],
    diffs[Math.floor(diffs.length*0.4)],
    diffs[Math.floor(diffs.length*0.6)],
    diffs[Math.floor(diffs.length*0.8)]
  ];
}

function round1(v){ return (typeof v === 'number') ? Math.round(v*10)/10 : v; }

function featureValue(feature) {
  const rec = (feature.properties.data||[]).find(d => d.Sex === selectedSex && d.GroupedYear === years[currentYearIndex]);
  return rec ? rec.Value : null;
}

function getFeatureColor(feature) {
  if (!feature || !feature.properties) return '#ccc';
  if (mode === 'absolute') {
    const val = featureValue(feature);
    if (val == null) return '#ccc';
    if (val > breaks[3]) return colors[6];
    if (val > breaks[2]) return colors[5];
    if (val > breaks[1]) return colors[4];
    if (val > breaks[0]) return colors[3];
    return colors[0];
  } else {
    const fYr = years[0], lYr = years[years.length-1];
    const a = (feature.properties.data||[]).find(d => d.Sex === selectedSex && d.GroupedYear === fYr);
    const b = (feature.properties.data||[]).find(d => d.Sex === selectedSex && d.GroupedYear === lYr);
    if (!a || !b || typeof a.Value !== 'number' || typeof b.Value !== 'number') return '#ccc';
    const diff = round1(b.Value - a.Value);
    const cb = computeChangeBreaks(deaDataCache);
    if (diff > cb[3]) return changeColors[6];
    if (diff > cb[2]) return changeColors[5];
    if (diff > cb[1]) return changeColors[4];
    if (diff > cb[0]) return changeColors[3];
    return changeColors[0];
  }
}

function updateMapStyles() {
  if (!deaLayer) return;
  if (mode === 'absolute') computeBreaks(deaDataCache);

  deaLayer.eachLayer(layer => {
    // animated transition: set fill by manipulating the path to trigger CSS transition
    const newColor = getFeatureColor(layer.feature);
    if (layer._path) {
      layer._path.style.transition = 'fill 600ms ease, fill-opacity 600ms ease, stroke 300ms ease';
      layer._path.style.fill = newColor;
    } else {
      layer.setStyle({ fillColor: newColor });
    }
  });
  updateLegend();
}

// Update legend with min/max and nicely rounded values
function updateLegend() {
  const div = document.getElementById('legend-content');
  if (mode === 'absolute') {
    // compute min/max over current year selection
    const vals = [];
    deaDataCache.features.forEach(f => {
      const rec = (f.properties.data||[]).find(d => d.Sex === selectedSex && d.GroupedYear === years[currentYearIndex]);
      if (rec && typeof rec.Value === 'number') vals.push(rec.Value);
    });
    const min = vals.length ? round1(Math.min(...vals)) : 'n/a';
    const max = vals.length ? round1(Math.max(...vals)) : 'n/a';

    let html = `<b>${selectedSex} (${years[currentYearIndex]})</b><br>`;
    html += `<small>min: ${min} — max: ${max}</small><br><br>`;
    const ranges = [0, ...breaks, 'max'];
    for (let i = 0; i < breaks.length; i++) {
      const labelLow = i===0 ? min : round1(breaks[i-1]);
      const labelHigh = i < breaks.length ? round1(breaks[i]) : max;
      html += `<i style="background:${colors[i+1]}"></i> ${labelLow} – ${labelHigh}<br>`;
    }
    div.innerHTML = html;
  } else {
    // change mode
    const cb = computeChangeBreaks(deaDataCache);
    // compute min/max change
    const changes = [];
    const fYr = years[0], lYr = years[years.length-1];
    deaDataCache.features.forEach(f => {
      const a = (f.properties.data||[]).find(d => d.Sex===selectedSex && d.GroupedYear===fYr);
      const b = (f.properties.data||[]).find(d => d.Sex===selectedSex && d.GroupedYear===lYr);
      if (a && b && typeof a.Value === 'number' && typeof b.Value === 'number') changes.push(round1(b.Value - a.Value));
    });
    const min = changes.length ? Math.min(...changes) : 'n/a';
    const max = changes.length ? Math.max(...changes) : 'n/a';

    let html = `<b>Change ${years[0]} → ${years[years.length-1]} (${selectedSex})</b><br>`;
    html += `<small>min: ${min} — max: ${max}</small><br><br>`;
    // show simple diverging legend
    for (let i=0;i<7;i++){
      const label = (i===0) ? `≤ ${cb[0]}` : (i===6) ? `≥ ${cb[3]}` : '';
      html += `<i style="background:${changeColors[i]}"></i> ${label}<br>`;
    }
    div.innerHTML = html;
  }
}

function updateYearLabel() {
  document.getElementById('year-label').textContent = years[currentYearIndex];
}

// Populate sidebar from feature (hover-driven)
function populateSidebarFromFeature(feature) {
  const props = feature.properties;
  document.getElementById('sidebar-title').textContent = props.DEA_NAME || 'DEA';
  const curVal = featureValue(feature);
  document.getElementById('sidebar-meta').innerHTML = `
    <strong>${selectedSex}</strong><br>
    Period: ${years[0]} → ${years[years.length-1]}<br>
    Current (${years[currentYearIndex]}): ${curVal!=null ? round1(curVal) + ' yrs' : 'n/a'}
  `;

  // Prepare timeseries
  const ts = (props.data||[]).filter(d => d.Sex===selectedSex).sort((a,b)=>(''+a.GroupedYear).localeCompare(''+b.GroupedYear));
  const labels = ts.map(d=>d.GroupedYear);
  const values = ts.map(d=>round1(d.Value));

  if (deaChart) deaChart.destroy();
  const ctx = document.getElementById('deaChart').getContext('2d');
  deaChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label: `${props.DEA_NAME} (${selectedSex})`,
        data: values,
        tension: 0.3,
        borderWidth: 2,
        pointRadius: 3,
        fill: false
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: { title: { display: true, text: 'HLE (years)' } },
        x: { title: { display: true, text: 'Period' } }
      }
    }
  });

  // wire download and zoom
  document.getElementById('download-csv').onclick = () => downloadDEADataAsCSV(props);
  document.getElementById('zoom-to').onclick = () => {
    // find layer and zoom
    deaLayer.eachLayer(layer => {
      if (layer.feature && layer.feature.properties && layer.feature.properties.DEA_NAME === props.DEA_NAME) {
        if (layer.getBounds) map.fitBounds(layer.getBounds().pad(0.4));
      }
    });
  };
}

// CSV download
function downloadDEADataAsCSV(props) {
  const rows = [['GroupedYear','Sex','Value']];
  (props.data||[]).forEach(d => rows.push([d.GroupedYear, d.Sex, d.Value==null ? '' : d.Value]));
  const csv = rows.map(r => r.map(c => `"${String(c).replace(/"/g,'""')}"`).join(',')).join('\n');
  const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${props.DEA_NAME || 'DEA'}_timeseries.csv`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

// ---------------- events ----------------
document.getElementById('tab-males').onclick = () => {
  selectedSex = 'Males';
  document.getElementById('tab-males').classList.add('active');
  document.getElementById('tab-females').classList.remove('active');
  updateMapStyles();
};

document.getElementById('tab-females').onclick = () => {
  selectedSex = 'Females';
  document.getElementById('tab-females').classList.add('active');
  document.getElementById('tab-males').classList.remove('active');
  updateMapStyles();
};

document.getElementById('year-slider').oninput = e => {
  currentYearIndex = +e.target.value;
  updateYearLabel();
  updateMapStyles();
};

document.getElementById('play-btn').onclick = () => {
  if (playInterval) {
    clearInterval(playInterval);
    playInterval = null;
    document.getElementById('play-btn').textContent = '▶ Play';
  } else {
    document.getElementById('play-btn').textContent = '⏸ Pause';
    playInterval = setInterval(() => {
      currentYearIndex = (currentYearIndex + 1) % years.length;
      document.getElementById('year-slider').value = currentYearIndex;
      updateYearLabel();
      updateMapStyles();
    }, 1500);
  }
};

document.getElementById('close-sidebar').onclick = () => {
  document.getElementById('sidebar').style.display = 'none';
  if (lastHoveredLayer) deaLayer.resetStyle(lastHoveredLayer);
  lastHoveredLayer = null;
};

document.querySelectorAll('input[name="mode"]').forEach(r => {
  r.addEventListener('change', e => {
    mode = e.target.value;
    updateMapStyles();
  });
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NI DEA Life Expectancy Map</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Chart.js -->
  <script src="https://unpkg.com/chart.js@4.3.0/dist/chart.umd.js"></script>

  <!-- Chart.js Annotation Plugin -->
  <script src="https://unpkg.com/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
  <script>Chart.register(window['chartjs-plugin-annotation']);</script>

  <style>
    body { margin: 0; font-family: Arial, sans-serif; }
    #map { height: 100vh; }

    .controls {
      position: absolute;
      top: 10px; left: 10px; z-index: 1000;
      background: white; padding: 10px; border-radius: 6px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      width: 340px;
    }
    .tabs { margin-bottom: 6px; }
    .tabs button {
      margin: 2px; padding: 6px 10px; border: none; cursor: pointer;
      background: #eee; border-radius: 4px;
    }
    .tabs button.active { background: #0078A8; color: white; }

    #year-slider { width: 100%; margin-top: 8px; }

    #play-btn {
      margin-top: 6px; padding: 6px 10px;
      background: #eee; border-radius: 4px; cursor: pointer;
    }

    .legend { background: white; padding: 6px; border-radius: 4px; font-size: 12px; }
    .legend i {
      width: 18px; height: 18px;
      float: left; margin-right: 8px;
      opacity: 0.95;
    }

    /* Sidebar */
    #sidebar {
      position: absolute;
      right: 10px;
      top: 10px;
      width: 420px;
      max-height: calc(100vh - 20px);
      overflow: auto;
      z-index: 1000;
      background: white;
      padding: 12px;
      border-radius: 6px;
      display: none;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    }
    #chart-container { height: 260px; }

    /* Spinner */
    #spinner {
      position: absolute;
      left: 50%; top: 50%;
      transform: translate(-50%, -50%);
      display: none;
      z-index: 2000;
    }
    .spinner-dot {
      width: 16px; height: 16px; margin: 4px;
      border-radius: 50%;
      background: #0078A8; opacity: 0.9;
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin { 0% {transform:scale(1);} 50% {transform:scale(0.45);} 100% {transform:scale(1);} }

    .leaflet-interactive {
      transition: fill 600ms ease, fill-opacity 600ms ease, stroke 300ms ease;
    }

    /* logo bottom-left */
    #assembly-logo {
      position: absolute;
      bottom: 10px;
      left: 10px;
      width: 140px;
      z-index: 1100;
      opacity: 0.95;
      pointer-events: none;
    }

    @media (max-width: 900px) {
      .controls { width: 280px; }
      #sidebar { width: 320px; }
    }

    /* small legend fix to clear floats */
    .legend:after { content: ""; display: block; clear: both; }
  </style>
</head>
<body>

  <div id="map"></div>
  <img id="assembly-logo" src="NI_Assembly.svg" alt="NI Assembly Logo">

  <div id="spinner">
    <div class="spinner-dot" style="animation-delay:0s"></div>
    <div class="spinner-dot" style="animation-delay:0.12s"></div>
    <div class="spinner-dot" style="animation-delay:0.24s"></div>
  </div>

  <div class="controls">
    <div class="tabs">
      <button id="tab-males" class="active">Males</button>
      <button id="tab-females">Females</button>
    </div>

    <div class="slider-container">
      <input type="range" id="year-slider" min="0" max="0" step="1" value="0" />
      <div id="year-label" style="margin-top:5px;font-weight:bold;"></div>
      <button id="play-btn">▶ Play Years</button>
    </div>

    <div style="margin-top:10px;">
      <label><input type="radio" name="mode" value="absolute" checked> Show absolute (year)</label><br>
      <label><input type="radio" name="mode" value="change"> Show change (first → last)</label>
    </div>

    <div style="margin-top:10px;">
      <b>Chart y-axis</b><br>
      <label><input type="radio" name="yaxis" value="dynamic"> Dynamic (per chart)</label><br>
      <label><input type="radio" name="yaxis" value="fixed" checked> Fixed (global)</label>
    </div>
  </div>

  <div id="sidebar">
    <button id="close-sidebar" style="float:right">Close</button>
    <h3 id="sidebar-title">DEA details</h3>
    <div id="sidebar-meta"></div>
    <div id="chart-container"><canvas id="deaChart"></canvas></div>
  </div>

  <script>
  // ================= CONFIG =================
  // User confirmed 7-class inverted ramp (dark = low, light = high)
  const colors = [
    "#28326f", "#265188", "#246b9e", "#2285b3", "#6baccb", "#b4d2e3", "#dee8f1"
  ];

  const geojsonUrl = 'DEA_data.geojson';

  let selectedSex = 'Males';
  let years = [];
  let currentYearIndex = 0;
  let mode = 'absolute';      // 'absolute' or 'change'
  let yAxisMode = 'fixed';    // 'fixed' or 'dynamic'
  let deaDataCache = null;
  let deaLayer = null;
  let lastHoveredLayer = null;
  let deaChart = null;
  let playInterval = null;

  // breaks
  let breaks = [];       // for absolute values (6 breakpoints -> 7 classes)
  let changeBreaks = []; // for diffs

  // global y axis bounds (computed across all values)
  let globalMinValue = null;
  let globalMaxValue = null;

  // map init
  const map = L.map('map').setView([54.7, -6.6], 8);
  L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap & Carto'
  }).addTo(map);

  const legend = L.control({position: 'bottomright'});
  legend.onAdd = function() {
    const div = L.DomUtil.create('div', 'legend');
    div.innerHTML = '<div id="legend-content"></div>';
    return div;
  };
  legend.addTo(map);

  const spinner = document.getElementById('spinner');
  function showSpinner(on = true) { spinner.style.display = on ? 'block' : 'none'; }

  showSpinner(true);

  // ---------------- Load GeoJSON ----------------
  fetch(geojsonUrl)
    .then(r => {
      if (!r.ok) throw new Error('GeoJSON load failed: ' + r.statusText);
      return r.json();
    })
    .then(data => {
      deaDataCache = data;

      // collect years
      const yearSet = new Set();
      data.features.forEach(f => {
        (f.properties.data || []).forEach(d => yearSet.add(d.GroupedYear));
      });
      years = Array.from(yearSet).sort();
      if (years.length === 0) {
        alert('No year data found in GeoJSON.');
        showSpinner(false);
        return;
      }

      document.getElementById('year-slider').max = years.length - 1;
      updateYearLabel();

      // compute global y-axis bounds for fixed mode
      computeGlobalBounds();

      // break calculations
      computeBreaks();
      computeChangeBreaks();

      // create layer
      const highlightStyle = { weight: 3, color: '#000', fillOpacity: 1 };
      deaLayer = L.geoJSON(data, {
        style: feature => ({
          weight: 1,
          color: '#555',
          fillColor: getFeatureColor(feature),
          fillOpacity: 0.85
        }),
        onEachFeature: (feature, layer) => {
          layer.on('mouseover', () => {
            if (lastHoveredLayer && lastHoveredLayer !== layer) deaLayer.resetStyle(lastHoveredLayer);
            lastHoveredLayer = layer;
            layer.setStyle(highlightStyle);
            populateSidebar(feature);
            document.getElementById('sidebar').style.display = 'block';
          });
          layer.on('mouseout', () => {
            deaLayer.resetStyle(layer);
            lastHoveredLayer = null;
            document.getElementById('sidebar').style.display = 'none';
            if (deaChart) { deaChart.destroy(); deaChart = null; }
          });
        }
      }).addTo(map);

      map.fitBounds(deaLayer.getBounds(), { padding: [20,20] });
      updateLegend();
      showSpinner(false);
    })
    .catch(err => {
      console.error(err);
      showSpinner(false);
      alert('Error loading data: ' + err.message);
    });

  // ================ HELPERS =================
  function round1(v) { return (typeof v === 'number') ? Math.round(v * 10) / 10 : v; }

  function updateYearLabel() {
    const yl = document.getElementById('year-label');
    yl.textContent = years[currentYearIndex];
  }

  // compute global min/max across all data (used when fixed y-axis selected)
  function computeGlobalBounds() {
    let gmin = Infinity, gmax = -Infinity;
    deaDataCache.features.forEach(f => {
      (f.properties.data || []).forEach(d => {
        if (typeof d.Value === 'number') {
          if (d.Value < gmin) gmin = d.Value;
          if (d.Value > gmax) gmax = d.Value;
        }
      });
    });
    if (!isFinite(gmin) || !isFinite(gmax)) {
      globalMinValue = null;
      globalMaxValue = null;
      return;
    }
    globalMinValue = Math.floor(gmin - 1);
    globalMaxValue = Math.ceil(gmax + 1);
  }

  // return value for feature for current year+sex
  function featureValue(feature, yearIndex = currentYearIndex, sex = selectedSex) {
    const y = years[yearIndex];
    const rec = (feature.properties.data || []).find(d => d.Sex === sex && d.GroupedYear === y);
    return rec ? rec.Value : null;
  }

  // compute NI average vector (per year) for selected sex (simple mean)
  function computeNIAverage(sex) {
    return years.map(y => {
      const vals = [];
      deaDataCache.features.forEach(f => {
        const rec = (f.properties.data || []).find(d => d.Sex === sex && d.GroupedYear === y);
        if (rec && typeof rec.Value === 'number') vals.push(rec.Value);
      });
      if (vals.length === 0) return null;
      const sum = vals.reduce((a,b) => a + b, 0);
      return round1(sum / vals.length);
    });
  }

  // compute equal-interval breaks for absolute mode (7 classes)
  function computeBreaks() {
    const vals = [];
    deaDataCache.features.forEach(f => {
      const rec = (f.properties.data || []).find(
        d => d.Sex === selectedSex && d.GroupedYear === years[currentYearIndex]
      );
      if (rec && typeof rec.Value === 'number') vals.push(rec.Value);
    });
    if (vals.length === 0) { breaks = []; return; }
    const min = Math.min(...vals);
    const max = Math.max(...vals);
    const step = (max - min) / 7;
    breaks = Array.from({length:6}, (_, i) => round1(min + step * (i + 1)));
  }

  // compute equal-interval breaks for change mode (diffs between first and last)
  function computeChangeBreaks() {
    const diffs = [];
    const fYr = years[0], lYr = years[years.length - 1];
    deaDataCache.features.forEach(f => {
      const a = (f.properties.data || []).find(d => d.Sex === selectedSex && d.GroupedYear === fYr);
      const b = (f.properties.data || []).find(d => d.Sex === selectedSex && d.GroupedYear === lYr);
      if (a && b && typeof a.Value === 'number' && typeof b.Value === 'number') {
        diffs.push(round1(b.Value - a.Value));
      }
    });
    if (diffs.length === 0) { changeBreaks = []; return; }
    const min = Math.min(...diffs);
    const max = Math.max(...diffs);
    const step = (max - min) / 7;
    changeBreaks = Array.from({length:6}, (_, i) => round1(min + step * (i + 1)));
  }

  // get colour for a feature depending on mode
  function getFeatureColor(feature) {
    if (mode === 'absolute') {
      const val = featureValue(feature);
      if (val == null) return '#ccc';
      if (breaks.length !== 6) return colors[0];
      if (val <= breaks[0]) return colors[0];
      if (val <= breaks[1]) return colors[1];
      if (val <= breaks[2]) return colors[2];
      if (val <= breaks[3]) return colors[3];
      if (val <= breaks[4]) return colors[4];
      if (val <= breaks[5]) return colors[5];
      return colors[6];
    } else {
      // change mode
      if (changeBreaks.length !== 6) return colors[0];
      const fYr = years[0], lYr = years[years.length - 1];
      const a = (feature.properties.data || []).find(d => d.Sex === selectedSex && d.GroupedYear === fYr);
      const b = (feature.properties.data || []).find(d => d.Sex === selectedSex && d.GroupedYear === lYr);
      if (!a || !b || typeof a.Value !== 'number' || typeof b.Value !== 'number') return '#ccc';
      const diff = round1(b.Value - a.Value);
      if (diff <= changeBreaks[0]) return colors[0];
      if (diff <= changeBreaks[1]) return colors[1];
      if (diff <= changeBreaks[2]) return colors[2];
      if (diff <= changeBreaks[3]) return colors[3];
      if (diff <= changeBreaks[4]) return colors[4];
      if (diff <= changeBreaks[5]) return colors[5];
      return colors[6];
    }
  }

  // update map styles and legend
  function updateMapStyles() {
    if (!deaLayer) return;
    if (mode === 'absolute') computeBreaks();
    else computeChangeBreaks();

    deaLayer.eachLayer(layer => {
      const c = getFeatureColor(layer.feature);
      layer.setStyle({ fillColor: c });
    });

    updateLegend();
  }

  // update legend to reflect current mode & breaks
  function updateLegend() {
    const div = document.getElementById('legend-content');
    if (!deaDataCache) { div.innerHTML = ''; return; }

    if (mode === 'absolute') {
      const vals = [];
      deaDataCache.features.forEach(f => {
        const rec = (f.properties.data || []).find(d => d.Sex === selectedSex && d.GroupedYear === years[currentYearIndex]);
        if (rec && typeof rec.Value === 'number') vals.push(rec.Value);
      });
      const min = vals.length ? round1(Math.min(...vals)) : 'n/a';
      const max = vals.length ? round1(Math.max(...vals)) : 'n/a';

      let html = `<b>${selectedSex} (${years[currentYearIndex]})</b><br>`;
      html += `<small>min: ${min} — max: ${max}</small><br><br>`;

      if (breaks.length === 6) {
        html += `<i style="background:${colors[0]}"></i> ${min} – ${breaks[0]}<br>`;
        html += `<i style="background:${colors[1]}"></i> ${breaks[0]} – ${breaks[1]}<br>`;
        html += `<i style="background:${colors[2]}"></i> ${breaks[1]} – ${breaks[2]}<br>`;
        html += `<i style="background:${colors[3]}"></i> ${breaks[2]} – ${breaks[3]}<br>`;
        html += `<i style="background:${colors[4]}"></i> ${breaks[3]} – ${breaks[4]}<br>`;
        html += `<i style="background:${colors[5]}"></i> ${breaks[4]} – ${breaks[5]}<br>`;
        html += `<i style="background:${colors[6]}"></i> > ${breaks[5]}<br>`;
      } else {
        for (let i=0;i<7;i++) html += `<i style="background:${colors[i]}"></i> class ${i+1}<br>`;
      }
      div.innerHTML = html;
      return;
    }

    // change mode legend
    const diffs = [];
    const fYr = years[0], lYr = years[years.length - 1];
    deaDataCache.features.forEach(f => {
      const a = (f.properties.data || []).find(d => d.Sex === selectedSex && d.GroupedYear === fYr);
      const b = (f.properties.data || []).find(d => d.Sex === selectedSex && d.GroupedYear === lYr);
      if (a && b && typeof a.Value === 'number' && typeof b.Value === 'number') diffs.push(round1(b.Value - a.Value));
    });
    const min = diffs.length ? Math.min(...diffs) : 'n/a';
    const max = diffs.length ? Math.max(...diffs) : 'n/a';

    let html = `<b>Change ${fYr} → ${lYr} (${selectedSex})</b><br>`;
    html += `<small>min: ${min} — max: ${max}</small><br><br>`;
    if (changeBreaks.length === 6) {
      html += `<i style="background:${colors[0]}"></i> ${min} – ${changeBreaks[0]}<br>`;
      html += `<i style="background:${colors[1]}"></i> ${changeBreaks[0]} – ${changeBreaks[1]}<br>`;
      html += `<i style="background:${colors[2]}"></i> ${changeBreaks[1]} – ${changeBreaks[2]}<br>`;
      html += `<i style="background:${colors[3]}"></i> ${changeBreaks[2]} – ${changeBreaks[3]}<br>`;
      html += `<i style="background:${colors[4]}"></i> ${changeBreaks[3]} – ${changeBreaks[4]}<br>`;
      html += `<i style="background:${colors[5]}"></i> ${changeBreaks[4]} – ${changeBreaks[5]}<br>`;
      html += `<i style="background:${colors[6]}"></i> > ${changeBreaks[5]}<br>`;
    } else {
      for (let i=0;i<7;i++) html += `<i style="background:${colors[i]}"></i> class ${i+1}<br>`;
    }
    div.innerHTML = html;
  }

  // ============== CHART BUILD ==============
  // Build Chart.js chart for hovered DEA
  function buildChart(feature) {
    const ctx = document.getElementById('deaChart').getContext('2d');

    // DEA values across years for selected sex
    const deaRecords = years.map(y => {
      const rec = (feature.properties.data || []).find(d => d.Sex === selectedSex && d.GroupedYear === y);
      return rec && typeof rec.Value === 'number' ? round1(rec.Value) : null;
    });

    // NI average computed across all DEAs for each year (simple mean)
    const niRecords = computeNIAverage(selectedSex);

    // determine y-axis min/max depending on yAxisMode
    let chartMin = null, chartMax = null;
    if (yAxisMode === 'fixed' && globalMinValue != null && globalMaxValue != null) {
      chartMin = globalMinValue;
      chartMax = globalMaxValue;
    } else {
      // dynamic: compute min/max from DEA + NI series (ignoring nulls)
      const combined = [];
      deaRecords.forEach(v => { if (typeof v === 'number') combined.push(v); });
      niRecords.forEach(v => { if (typeof v === 'number') combined.push(v); });
      if (combined.length > 0) {
        chartMin = Math.floor(Math.min(...combined) - 1);
        chartMax = Math.ceil(Math.max(...combined) + 1);
      }
    }

    const selectedIndex = currentYearIndex;

    if (deaChart) deaChart.destroy();

    deaChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: years,
        datasets: [
          {
            label: feature.properties.finalr_dea || 'DEA',
            data: deaRecords,
            borderColor: '#0078A8',
            backgroundColor: 'rgba(0,120,168,0.16)',
            fill: true,
            pointRadius: 3,
            tension: 0.3,
            borderWidth: 2
          },
          {
            label: 'Northern Ireland (avg)',
            data: niRecords,
            borderColor: '#444',
            backgroundColor: 'transparent',
            fill: false,
            borderDash: [5,5],
            pointRadius: 0,
            tension: 0.3,
            borderWidth: 2
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: false,
        scales: {
          x: {
            title: { display: true, text: 'Period' }
          },
          y: {
            title: { display: true, text: 'HLE (years)' },
            min: (chartMin != null ? chartMin : undefined),
            max: (chartMax != null ? chartMax : undefined)
          }
        },
        plugins: {
          legend: { display: false },
          annotation: {
            annotations: {
              shadeLeft: {
                type: 'box',
                xMin: 0,
                xMax: selectedIndex >= 0 ? selectedIndex : 0,
                backgroundColor: 'rgba(0,0,0,0.04)'
              },
              currentYearLine: {
                type: 'line',
                xMin: selectedIndex >= 0 ? selectedIndex : 0,
                xMax: selectedIndex >= 0 ? selectedIndex : 0,
                borderColor: 'rgba(0,0,0,0.45)',
                borderWidth: 1,
                borderDash: [4,4]
              }
            }
          }
        }
      }
    });
  }

  // Update only the annotations when year selection changes
  function updateSidebarChartForSelectedYear() {
    if (!deaChart) return;
    const selectedIndex = currentYearIndex;
    const ann = deaChart.options.plugins.annotation.annotations;
    if (ann) {
      if (ann.currentYearLine) {
        ann.currentYearLine.xMin = selectedIndex;
        ann.currentYearLine.xMax = selectedIndex;
      }
      if (ann.shadeLeft) {
        ann.shadeLeft.xMax = selectedIndex;
      }
      deaChart.update();
    }
  }

  // populate sidebar text + chart
  function populateSidebar(feature) {
    const props = feature.properties || {};
    const curVal = featureValue(feature);

    document.getElementById('sidebar-title').textContent = `DEA – ${props.finalr_dea || 'Unknown'}`;
    document.getElementById('sidebar-meta').innerHTML = `
      <strong>${selectedSex}</strong><br>
      Period: ${years[0]} → ${years[years.length - 1]}<br>
      Current (${years[currentYearIndex]}): ${curVal != null ? round1(curVal) + ' yrs' : 'n/a'}
    `;

    // build chart for this feature
    buildChart(feature);
  }

  // compute NI average vector used by chart
  function computeNIAverage(sex) {
    return years.map(y => {
      const vals = [];
      deaDataCache.features.forEach(f => {
        const rec = (f.properties.data || []).find(d => d.Sex === sex && d.GroupedYear === y);
        if (rec && typeof rec.Value === 'number') vals.push(rec.Value);
      });
      if (vals.length === 0) return null;
      const sum = vals.reduce((a,b) => a + b, 0);
      return round1(sum / vals.length);
    });
  }

  // ============== UI interactions ==============
  function updateTabs() {
    document.getElementById('tab-males').classList.remove('active');
    document.getElementById('tab-females').classList.remove('active');
    if (selectedSex === 'Males') document.getElementById('tab-males').classList.add('active');
    else document.getElementById('tab-females').classList.add('active');
  }

  // Slider handler
  document.getElementById('year-slider').addEventListener('input', e => {
    currentYearIndex = Number(e.target.value);
    updateYearLabel();
    updateMapStyles();
    updateSidebarChartForSelectedYear();
  });

  // Tabs
  document.getElementById('tab-males').onclick = () => {
    selectedSex = 'Males';
    updateTabs();
    computeBreaks();
    computeChangeBreaks();
    updateMapStyles();
    if (lastHoveredLayer && lastHoveredLayer.feature) populateSidebar(lastHoveredLayer.feature);
  };
  document.getElementById('tab-females').onclick = () => {
    selectedSex = 'Females';
    updateTabs();
    computeBreaks();
    computeChangeBreaks();
    updateMapStyles();
    if (lastHoveredLayer && lastHoveredLayer.feature) populateSidebar(lastHoveredLayer.feature);
  };

  // Play button
  document.getElementById('play-btn').addEventListener('click', () => {
    if (playInterval) {
      clearInterval(playInterval);
      playInterval = null;
      document.getElementById('play-btn').textContent = '▶ Play Years';
    } else {
      document.getElementById('play-btn').textContent = '⏸ Pause';
      playInterval = setInterval(() => {
        currentYearIndex = (currentYearIndex + 1) % years.length;
        document.getElementById('year-slider').value = currentYearIndex;
        updateYearLabel();
        updateMapStyles();
        updateSidebarChartForSelectedYear();
      }, 1400);
    }
  });

  // Close sidebar
  document.getElementById('close-sidebar').onclick = () => {
    document.getElementById('sidebar').style.display = 'none';
    if (lastHoveredLayer) deaLayer.resetStyle(lastHoveredLayer);
    lastHoveredLayer = null;
    if (deaChart) { deaChart.destroy(); deaChart = null; }
  };

  // Mode radio buttons (absolute / change)
  document.querySelectorAll('input[name="mode"]').forEach(r => {
    r.addEventListener('change', e => {
      mode = e.target.value;
      if (mode === 'absolute') computeBreaks();
      else computeChangeBreaks();
      updateMapStyles();
      if (lastHoveredLayer && lastHoveredLayer.feature) populateSidebar(lastHoveredLayer.feature);
    });
  });

  // Y-axis radio buttons (dynamic / fixed)
  document.querySelectorAll('input[name="yaxis"]').forEach(r => {
    r.addEventListener('change', e => {
      yAxisMode = e.target.value;
      // rebuild chart if open
      if (lastHoveredLayer && lastHoveredLayer.feature) populateSidebar(lastHoveredLayer.feature);
    });
  });

  // initial tab state
  updateTabs();

  </script>

</body>
</html>
